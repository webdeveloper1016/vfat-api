"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convert = void 0;
const ts_morph_1 = require("ts-morph");
const add_class_property_declarations_1 = require("./add-class-property-declarations/add-class-property-declarations");
const add_optionals_to_function_params_1 = require("./add-optionals-to-function-params");
const filter_out_node_modules_1 = require("./filter-out-node-modules");
const logger_1 = __importDefault(require("../logger/logger"));
/**
 * Converts the source .js code to .ts
 */
function convert(tsAstProject) {
    if (tsAstProject.getSourceFiles().length === 0) {
        logger_1.default.info('Found no source files to process. Exiting.');
        return tsAstProject;
    }
    // Print input files
    logger_1.default.info('Processing the following source files:');
    printSourceFilesList(tsAstProject, '  ');
    logger_1.default.info(`
		Converting source files... This may take anywhere from a few minutes to 
		tens of minutes or longer depending on how many files are being 
		converted.
	`.replace(/\t*/gm, ''));
    // Fill in PropertyDeclarations for properties used by ES6 classes
    logger_1.default.info('Adding property declarations to JS Classes...');
    tsAstProject = add_class_property_declarations_1.addClassPropertyDeclarations(tsAstProject);
    // Rename .js files to .ts files
    logger_1.default.info('Renaming .js files to .ts');
    tsAstProject.getSourceFiles().forEach(sourceFile => {
        const ext = sourceFile.getExtension();
        if (ext === '.js' || ext === '.jsx') {
            const dir = sourceFile.getDirectoryPath();
            const basename = sourceFile.getBaseNameWithoutExtension();
            // in case there's a '.js' file which has JSX in it
            const fileHasJsx = sourceFile.getFirstDescendantByKind(ts_morph_1.SyntaxKind.JsxElement)
                || sourceFile.getFirstDescendantByKind(ts_morph_1.SyntaxKind.JsxSelfClosingElement);
            const extension = (fileHasJsx || ext === '.jsx') ? 'tsx' : 'ts';
            const outputFilePath = `${dir}/${basename}.${extension}`;
            logger_1.default.debug(`  Renaming ${sourceFile.getFilePath()} to ${outputFilePath}`);
            sourceFile.move(outputFilePath);
        }
    });
    // Filter out any node_modules files that accidentally got included by an import.
    // We don't want to modify these when we save the project
    tsAstProject = filter_out_node_modules_1.filterOutNodeModules(tsAstProject);
    // Make function parameters optional for calls that supply fewer arguments
    // than there are function parameters.
    // NOTE: Must happen after .js -> .ts rename for the TypeScript Language
    // Service to work.
    logger_1.default.info('Making parameters optional for calls that supply fewer args than function parameters...');
    tsAstProject = add_optionals_to_function_params_1.addOptionalsToFunctionParams(tsAstProject);
    // Filter out any node_modules files as we don't want to modify these when
    // we save the project. Also, some .d.ts files get included for some reason
    // like tslib.d.ts, so we don't want to output that as well.
    tsAstProject = filter_out_node_modules_1.filterOutNodeModules(tsAstProject);
    // Print output files
    logger_1.default.info('Outputting .ts files:');
    printSourceFilesList(tsAstProject, '  ');
    // Even though the `tsAstProject` has been mutated (it is not an immutable
    // data structure), return it anyway to avoid the confusion of an output
    // parameter.
    return tsAstProject;
}
exports.convert = convert;
/**
 * Private helper to print out the source files list in the given `astProject`
 * to the console.
 */
function printSourceFilesList(astProject, indent = '') {
    astProject.getSourceFiles().forEach(sf => {
        logger_1.default.info(`${indent}${sf.getFilePath()}`);
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udmVydC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb252ZXJ0ZXIvY29udmVydC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSx1Q0FBK0M7QUFDL0MsdUhBQWlIO0FBQ2pILHlGQUFrRjtBQUNsRix1RUFBaUU7QUFDakUsOERBQXNDO0FBRXRDOztHQUVHO0FBQ0gsU0FBZ0IsT0FBTyxDQUFFLFlBQXFCO0lBQzdDLElBQUksWUFBWSxDQUFDLGNBQWMsRUFBRSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUc7UUFDaEQsZ0JBQU0sQ0FBQyxJQUFJLENBQUUsNENBQTRDLENBQUUsQ0FBQztRQUM1RCxPQUFPLFlBQVksQ0FBQztLQUNwQjtJQUVELG9CQUFvQjtJQUNwQixnQkFBTSxDQUFDLElBQUksQ0FBRSx3Q0FBd0MsQ0FBRSxDQUFDO0lBQ3hELG9CQUFvQixDQUFFLFlBQVksRUFBRSxJQUFJLENBQUUsQ0FBQztJQUUzQyxnQkFBTSxDQUFDLElBQUksQ0FBRTs7OztFQUlaLENBQUMsT0FBTyxDQUFFLE9BQU8sRUFBRSxFQUFFLENBQUUsQ0FBRSxDQUFDO0lBRTNCLGtFQUFrRTtJQUNsRSxnQkFBTSxDQUFDLElBQUksQ0FBRSwrQ0FBK0MsQ0FBRSxDQUFDO0lBQy9ELFlBQVksR0FBRyw4REFBNEIsQ0FBRSxZQUFZLENBQUUsQ0FBQztJQUU1RCxnQ0FBZ0M7SUFDaEMsZ0JBQU0sQ0FBQyxJQUFJLENBQUUsMkJBQTJCLENBQUUsQ0FBQztJQUMzQyxZQUFZLENBQUMsY0FBYyxFQUFFLENBQUMsT0FBTyxDQUFFLFVBQVUsQ0FBQyxFQUFFO1FBQ25ELE1BQU0sR0FBRyxHQUFHLFVBQVUsQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUV0QyxJQUFJLEdBQUcsS0FBSyxLQUFLLElBQUksR0FBRyxLQUFLLE1BQU0sRUFBRztZQUNyQyxNQUFNLEdBQUcsR0FBRyxVQUFVLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztZQUMxQyxNQUFNLFFBQVEsR0FBRyxVQUFVLENBQUMsMkJBQTJCLEVBQUUsQ0FBQztZQUUxRCxtREFBbUQ7WUFDbkQsTUFBTSxVQUFVLEdBQUcsVUFBVSxDQUFDLHdCQUF3QixDQUFFLHFCQUFVLENBQUMsVUFBVSxDQUFFO21CQUMzRSxVQUFVLENBQUMsd0JBQXdCLENBQUUscUJBQVUsQ0FBQyxxQkFBcUIsQ0FBRSxDQUFDO1lBQzVFLE1BQU0sU0FBUyxHQUFHLENBQUUsVUFBVSxJQUFJLEdBQUcsS0FBSyxNQUFNLENBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFDbEUsTUFBTSxjQUFjLEdBQUcsR0FBRyxHQUFHLElBQUksUUFBUSxJQUFJLFNBQVMsRUFBRSxDQUFDO1lBRXpELGdCQUFNLENBQUMsS0FBSyxDQUFFLGNBQWMsVUFBVSxDQUFDLFdBQVcsRUFBRSxPQUFPLGNBQWMsRUFBRSxDQUFFLENBQUM7WUFDOUUsVUFBVSxDQUFDLElBQUksQ0FBRSxjQUFjLENBQUUsQ0FBQztTQUNsQztJQUNGLENBQUMsQ0FBRSxDQUFDO0lBRUosaUZBQWlGO0lBQ2pGLHlEQUF5RDtJQUN6RCxZQUFZLEdBQUcsOENBQW9CLENBQUUsWUFBWSxDQUFFLENBQUM7SUFFcEQsMEVBQTBFO0lBQzFFLHNDQUFzQztJQUN0Qyx3RUFBd0U7SUFDeEUsbUJBQW1CO0lBQ25CLGdCQUFNLENBQUMsSUFBSSxDQUFFLHlGQUF5RixDQUFFLENBQUM7SUFDekcsWUFBWSxHQUFHLCtEQUE0QixDQUFFLFlBQVksQ0FBRSxDQUFDO0lBRTVELDBFQUEwRTtJQUMxRSwyRUFBMkU7SUFDM0UsNERBQTREO0lBQzVELFlBQVksR0FBRyw4Q0FBb0IsQ0FBRSxZQUFZLENBQUUsQ0FBQztJQUVwRCxxQkFBcUI7SUFDckIsZ0JBQU0sQ0FBQyxJQUFJLENBQUUsdUJBQXVCLENBQUUsQ0FBQztJQUN2QyxvQkFBb0IsQ0FBRSxZQUFZLEVBQUUsSUFBSSxDQUFFLENBQUM7SUFFM0MsMEVBQTBFO0lBQzFFLHdFQUF3RTtJQUN4RSxhQUFhO0lBQ2IsT0FBTyxZQUFZLENBQUM7QUFDckIsQ0FBQztBQWhFRCwwQkFnRUM7QUFHRDs7O0dBR0c7QUFDSCxTQUFTLG9CQUFvQixDQUFFLFVBQW1CLEVBQUUsTUFBTSxHQUFHLEVBQUU7SUFDOUQsVUFBVSxDQUFDLGNBQWMsRUFBRSxDQUFDLE9BQU8sQ0FBRSxFQUFFLENBQUMsRUFBRTtRQUN6QyxnQkFBTSxDQUFDLElBQUksQ0FBRSxHQUFHLE1BQU0sR0FBRyxFQUFFLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBRSxDQUFDO0lBQy9DLENBQUMsQ0FBRSxDQUFDO0FBQ0wsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByb2plY3QsIFN5bnRheEtpbmQgfSBmcm9tIFwidHMtbW9ycGhcIjtcbmltcG9ydCB7IGFkZENsYXNzUHJvcGVydHlEZWNsYXJhdGlvbnMgfSBmcm9tIFwiLi9hZGQtY2xhc3MtcHJvcGVydHktZGVjbGFyYXRpb25zL2FkZC1jbGFzcy1wcm9wZXJ0eS1kZWNsYXJhdGlvbnNcIjtcbmltcG9ydCB7IGFkZE9wdGlvbmFsc1RvRnVuY3Rpb25QYXJhbXMgfSBmcm9tIFwiLi9hZGQtb3B0aW9uYWxzLXRvLWZ1bmN0aW9uLXBhcmFtc1wiO1xuaW1wb3J0IHsgZmlsdGVyT3V0Tm9kZU1vZHVsZXMgfSBmcm9tIFwiLi9maWx0ZXItb3V0LW5vZGUtbW9kdWxlc1wiO1xuaW1wb3J0IGxvZ2dlciBmcm9tIFwiLi4vbG9nZ2VyL2xvZ2dlclwiO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBzb3VyY2UgLmpzIGNvZGUgdG8gLnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0KCB0c0FzdFByb2plY3Q6IFByb2plY3QgKTogUHJvamVjdCB7XG5cdGlmKCB0c0FzdFByb2plY3QuZ2V0U291cmNlRmlsZXMoKS5sZW5ndGggPT09IDAgKSB7XG5cdFx0bG9nZ2VyLmluZm8oICdGb3VuZCBubyBzb3VyY2UgZmlsZXMgdG8gcHJvY2Vzcy4gRXhpdGluZy4nICk7XG5cdFx0cmV0dXJuIHRzQXN0UHJvamVjdDtcblx0fVxuXG5cdC8vIFByaW50IGlucHV0IGZpbGVzXG5cdGxvZ2dlci5pbmZvKCAnUHJvY2Vzc2luZyB0aGUgZm9sbG93aW5nIHNvdXJjZSBmaWxlczonICk7XG5cdHByaW50U291cmNlRmlsZXNMaXN0KCB0c0FzdFByb2plY3QsICcgICcgKTtcblxuXHRsb2dnZXIuaW5mbyggYFxuXHRcdENvbnZlcnRpbmcgc291cmNlIGZpbGVzLi4uIFRoaXMgbWF5IHRha2UgYW55d2hlcmUgZnJvbSBhIGZldyBtaW51dGVzIHRvIFxuXHRcdHRlbnMgb2YgbWludXRlcyBvciBsb25nZXIgZGVwZW5kaW5nIG9uIGhvdyBtYW55IGZpbGVzIGFyZSBiZWluZyBcblx0XHRjb252ZXJ0ZWQuXG5cdGAucmVwbGFjZSggL1xcdCovZ20sICcnICkgKTtcblxuXHQvLyBGaWxsIGluIFByb3BlcnR5RGVjbGFyYXRpb25zIGZvciBwcm9wZXJ0aWVzIHVzZWQgYnkgRVM2IGNsYXNzZXNcblx0bG9nZ2VyLmluZm8oICdBZGRpbmcgcHJvcGVydHkgZGVjbGFyYXRpb25zIHRvIEpTIENsYXNzZXMuLi4nICk7XG5cdHRzQXN0UHJvamVjdCA9IGFkZENsYXNzUHJvcGVydHlEZWNsYXJhdGlvbnMoIHRzQXN0UHJvamVjdCApO1xuXG5cdC8vIFJlbmFtZSAuanMgZmlsZXMgdG8gLnRzIGZpbGVzXG5cdGxvZ2dlci5pbmZvKCAnUmVuYW1pbmcgLmpzIGZpbGVzIHRvIC50cycgKTtcblx0dHNBc3RQcm9qZWN0LmdldFNvdXJjZUZpbGVzKCkuZm9yRWFjaCggc291cmNlRmlsZSA9PiB7XG5cdFx0Y29uc3QgZXh0ID0gc291cmNlRmlsZS5nZXRFeHRlbnNpb24oKTtcblxuXHRcdGlmKCBleHQgPT09ICcuanMnIHx8IGV4dCA9PT0gJy5qc3gnICkge1xuXHRcdFx0Y29uc3QgZGlyID0gc291cmNlRmlsZS5nZXREaXJlY3RvcnlQYXRoKCk7XG5cdFx0XHRjb25zdCBiYXNlbmFtZSA9IHNvdXJjZUZpbGUuZ2V0QmFzZU5hbWVXaXRob3V0RXh0ZW5zaW9uKCk7XG5cblx0XHRcdC8vIGluIGNhc2UgdGhlcmUncyBhICcuanMnIGZpbGUgd2hpY2ggaGFzIEpTWCBpbiBpdFxuXHRcdFx0Y29uc3QgZmlsZUhhc0pzeCA9IHNvdXJjZUZpbGUuZ2V0Rmlyc3REZXNjZW5kYW50QnlLaW5kKCBTeW50YXhLaW5kLkpzeEVsZW1lbnQgKVxuXHRcdFx0XHR8fCBzb3VyY2VGaWxlLmdldEZpcnN0RGVzY2VuZGFudEJ5S2luZCggU3ludGF4S2luZC5Kc3hTZWxmQ2xvc2luZ0VsZW1lbnQgKTtcblx0XHRcdGNvbnN0IGV4dGVuc2lvbiA9ICggZmlsZUhhc0pzeCB8fCBleHQgPT09ICcuanN4JyApID8gJ3RzeCcgOiAndHMnO1xuXHRcdFx0Y29uc3Qgb3V0cHV0RmlsZVBhdGggPSBgJHtkaXJ9LyR7YmFzZW5hbWV9LiR7ZXh0ZW5zaW9ufWA7XG5cblx0XHRcdGxvZ2dlci5kZWJ1ZyggYCAgUmVuYW1pbmcgJHtzb3VyY2VGaWxlLmdldEZpbGVQYXRoKCl9IHRvICR7b3V0cHV0RmlsZVBhdGh9YCApO1xuXHRcdFx0c291cmNlRmlsZS5tb3ZlKCBvdXRwdXRGaWxlUGF0aCApO1xuXHRcdH1cblx0fSApO1xuXG5cdC8vIEZpbHRlciBvdXQgYW55IG5vZGVfbW9kdWxlcyBmaWxlcyB0aGF0IGFjY2lkZW50YWxseSBnb3QgaW5jbHVkZWQgYnkgYW4gaW1wb3J0LlxuXHQvLyBXZSBkb24ndCB3YW50IHRvIG1vZGlmeSB0aGVzZSB3aGVuIHdlIHNhdmUgdGhlIHByb2plY3Rcblx0dHNBc3RQcm9qZWN0ID0gZmlsdGVyT3V0Tm9kZU1vZHVsZXMoIHRzQXN0UHJvamVjdCApO1xuXG5cdC8vIE1ha2UgZnVuY3Rpb24gcGFyYW1ldGVycyBvcHRpb25hbCBmb3IgY2FsbHMgdGhhdCBzdXBwbHkgZmV3ZXIgYXJndW1lbnRzXG5cdC8vIHRoYW4gdGhlcmUgYXJlIGZ1bmN0aW9uIHBhcmFtZXRlcnMuXG5cdC8vIE5PVEU6IE11c3QgaGFwcGVuIGFmdGVyIC5qcyAtPiAudHMgcmVuYW1lIGZvciB0aGUgVHlwZVNjcmlwdCBMYW5ndWFnZVxuXHQvLyBTZXJ2aWNlIHRvIHdvcmsuXG5cdGxvZ2dlci5pbmZvKCAnTWFraW5nIHBhcmFtZXRlcnMgb3B0aW9uYWwgZm9yIGNhbGxzIHRoYXQgc3VwcGx5IGZld2VyIGFyZ3MgdGhhbiBmdW5jdGlvbiBwYXJhbWV0ZXJzLi4uJyApO1xuXHR0c0FzdFByb2plY3QgPSBhZGRPcHRpb25hbHNUb0Z1bmN0aW9uUGFyYW1zKCB0c0FzdFByb2plY3QgKTtcblxuXHQvLyBGaWx0ZXIgb3V0IGFueSBub2RlX21vZHVsZXMgZmlsZXMgYXMgd2UgZG9uJ3Qgd2FudCB0byBtb2RpZnkgdGhlc2Ugd2hlblxuXHQvLyB3ZSBzYXZlIHRoZSBwcm9qZWN0LiBBbHNvLCBzb21lIC5kLnRzIGZpbGVzIGdldCBpbmNsdWRlZCBmb3Igc29tZSByZWFzb25cblx0Ly8gbGlrZSB0c2xpYi5kLnRzLCBzbyB3ZSBkb24ndCB3YW50IHRvIG91dHB1dCB0aGF0IGFzIHdlbGwuXG5cdHRzQXN0UHJvamVjdCA9IGZpbHRlck91dE5vZGVNb2R1bGVzKCB0c0FzdFByb2plY3QgKTtcblxuXHQvLyBQcmludCBvdXRwdXQgZmlsZXNcblx0bG9nZ2VyLmluZm8oICdPdXRwdXR0aW5nIC50cyBmaWxlczonICk7XG5cdHByaW50U291cmNlRmlsZXNMaXN0KCB0c0FzdFByb2plY3QsICcgICcgKTtcblxuXHQvLyBFdmVuIHRob3VnaCB0aGUgYHRzQXN0UHJvamVjdGAgaGFzIGJlZW4gbXV0YXRlZCAoaXQgaXMgbm90IGFuIGltbXV0YWJsZVxuXHQvLyBkYXRhIHN0cnVjdHVyZSksIHJldHVybiBpdCBhbnl3YXkgdG8gYXZvaWQgdGhlIGNvbmZ1c2lvbiBvZiBhbiBvdXRwdXRcblx0Ly8gcGFyYW1ldGVyLlxuXHRyZXR1cm4gdHNBc3RQcm9qZWN0O1xufVxuXG5cbi8qKlxuICogUHJpdmF0ZSBoZWxwZXIgdG8gcHJpbnQgb3V0IHRoZSBzb3VyY2UgZmlsZXMgbGlzdCBpbiB0aGUgZ2l2ZW4gYGFzdFByb2plY3RgXG4gKiB0byB0aGUgY29uc29sZS5cbiAqL1xuZnVuY3Rpb24gcHJpbnRTb3VyY2VGaWxlc0xpc3QoIGFzdFByb2plY3Q6IFByb2plY3QsIGluZGVudCA9ICcnICkge1xuXHRhc3RQcm9qZWN0LmdldFNvdXJjZUZpbGVzKCkuZm9yRWFjaCggc2YgPT4ge1xuXHRcdGxvZ2dlci5pbmZvKCBgJHtpbmRlbnR9JHtzZi5nZXRGaWxlUGF0aCgpfWAgKTtcblx0fSApO1xufSJdfQ==