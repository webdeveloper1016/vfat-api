"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseJsClasses = void 0;
const ts_morph_1 = require("ts-morph");
const js_class_1 = require("./js-class");
const set_utils_1 = require("../../util/set-utils");
const parse_destructured_props_1 = require("../../util/parse-destructured-props");
const parse_superclass_name_and_path_1 = require("./parse-superclass-name-and-path");
const is_this_referencing_var_1 = require("../../util/is-this-referencing-var");
const is_property_access_with_obj_1 = require("../../util/is-property-access-with-obj");
const logger_1 = __importDefault(require("../../logger/logger"));
/**
 * Parses the classes out of each .js file in the SourceFilesCollection, and
 * forms a tree representing their hierarchy.
 *
 * ## Description of algorithm:
 *
 * Each source file is parsed to find all file-level classes. Their superclasses
 * and import paths for those superclasses are also recorded to form an
 * adjacency list graph of classes keyed by their file path.
 *
 * Each class is also processed to find and record any property accesses of the
 * `this` object. For instance, in the following class, there are 3
 * PropertyAccessExpressions that pull from the `this` object ('something1',
 * 'something2', and 'something3'):
 *
 *     class Something {
 *         constructor() {
 *             this.something1 = 1;
 *             this.something2 = 2;
 *         }
 *
 *         someMethod() {
 *             console.log( this.something3 );
 *
 *             console.log( window.location );  // <-- not a `this` PropertyAccessExpression
 *         }
 *     }
 *
 * The returned graph will be used later to determine which TS class property
 * definitions should be placed in superclasses vs. subclasses. Properties used
 * by a superclass and a subclass should only be defined in the superclass.
 */
function parseJsClasses(tsAstProject) {
    logger_1.default.verbose("Parsing JS classes in the codebase...");
    const files = tsAstProject.getSourceFiles();
    const jsClasses = files.reduce((classes, file) => {
        logger_1.default.debug(`Parsing classes in file: ${file.getFilePath()}`);
        const fileClasses = parseFileClasses(file);
        return classes.concat(fileClasses);
    }, []);
    return jsClasses;
}
exports.parseJsClasses = parseJsClasses;
/**
 * Parses the file-level classes out of the given `sourceFile`.
 */
function parseFileClasses(sourceFile) {
    return sourceFile.getClasses().map(fileClass => {
        const className = fileClass.getName();
        logger_1.default.debug(`  Parsing class: ${className}`);
        const { superclassName, superclassPath } = parse_superclass_name_and_path_1.parseSuperclassNameAndPath(sourceFile, fileClass);
        const methodNames = getMethodNames(fileClass);
        const propertyNames = getPropertyNames(fileClass);
        const propertiesMinusMethods = set_utils_1.difference(propertyNames, methodNames); // remove any method names from this Set
        return new js_class_1.JsClass({
            path: sourceFile.getFilePath(),
            name: className,
            superclassName,
            superclassPath,
            methods: methodNames,
            properties: propertiesMinusMethods
        });
    });
}
/**
 * Parses the method names from the class into a Set of strings.
 */
function getMethodNames(fileClass) {
    return fileClass.getMethods()
        .reduce((methods, method) => {
        return methods.add(method.getName());
    }, new Set());
}
/**
 * Retrieves the list of propertyNames used in the class. This may also include
 * method names (which are technically properties), which we'll filter out later.
 */
function getPropertyNames(fileClass) {
    const existingPropertyDeclarations = parsePropertyDeclarations(fileClass); // in case we are actually parsing a TypeScript class with existing declarations
    const propertyAccesses = parsePropertyAccesses(fileClass);
    const destructuringUsesOfProperties = parseDestructuringThisAssignments(fileClass);
    const propertyAccessesOfThisAssignedVars = parsePropertyAccessesOfThisAssignedVars(fileClass);
    return set_utils_1.union(existingPropertyDeclarations, propertyAccesses, destructuringUsesOfProperties, propertyAccessesOfThisAssignedVars);
}
/**
 * In the case that the utility is actually parsing TypeScript classes with
 * existing property declarations, we want to know about these so we don't
 * accidentally write in new ones of the same name.
 */
function parsePropertyDeclarations(fileClass) {
    return fileClass.getInstanceProperties()
        .reduce((props, prop) => {
        const propName = prop.getName();
        return propName ? props.add(propName) : props; // don't add unnamed properties (not sure how we would have one of those, but seems its possible according to the TsSimpleAst types)
    }, new Set());
}
/**
 * Parses the property names of `this` PropertyAccessExpressions.
 *
 * Examples:
 *
 *     this.something = 42;
 *     console.log( this.something2 );
 *
 *     const { destructured1, destructured2 } = this;
 *
 * Method returns:
 *
 *    Set( [ 'something', 'something2', 'destructured1', 'destructured2' ] )
 */
function parsePropertyAccesses(fileClass) {
    // First, find all of the `this.something` properties
    const thisProps = fileClass
        .getDescendantsOfKind(ts_morph_1.SyntaxKind.PropertyAccessExpression)
        .filter((prop) => prop.getExpression().getKind() === ts_morph_1.SyntaxKind.ThisKeyword);
    const propNamesSet = thisProps
        .reduce((props, prop) => {
        return props.add(prop.getName());
    }, new Set());
    return propNamesSet;
}
/**
 * Parses any object destructuring statements of the form:
 *
 *     var { a, b } = this;
 *
 * And returns Set( [ 'a', 'b' ] ) in this case.
 */
function parseDestructuringThisAssignments(fileClass) {
    // Second, find any `var { a, b } = this` statements
    const destructuredProps = fileClass
        .getDescendantsOfKind(ts_morph_1.SyntaxKind.VariableDeclaration)
        .filter((varDec) => {
        return varDec.compilerNode.name.kind === ts_morph_1.SyntaxKind.ObjectBindingPattern;
    });
    return destructuredProps
        .reduce((propNames, varDec) => {
        const destructuredPropNames = parse_destructured_props_1.parseDestructuredProps(varDec.compilerNode.name);
        destructuredPropNames.forEach(propName => propNames.add(propName));
        return propNames;
    }, new Set());
}
/**
 * Parses property accesses of variables that are assigned to the `this`
 * keyword.
 *
 * For example:
 *
 *     var that = this;
 *
 *     that.someProp1 = 1;
 *     that.someProp2 = 2;
 *
 * In the above code, the Set( [ 'someProp1', 'someProp2' ] ) is returned
 */
function parsePropertyAccessesOfThisAssignedVars(fileClass) {
    const methods = fileClass.getMethods();
    return methods.reduce((propNames, method) => {
        const thisVarDeclarations = method
            .getDescendantsOfKind(ts_morph_1.SyntaxKind.VariableDeclaration)
            .filter(is_this_referencing_var_1.isThisReferencingVar);
        // Get the array of identifiers assigned to `this`. Ex: [ 'that', 'self' ]
        const thisVarIdentifiers = thisVarDeclarations
            .map((thisVarDec) => thisVarDec.getName());
        thisVarIdentifiers.forEach((thisVarIdentifier) => {
            // Get the properties accessed from the `this` identifiers (i.e. from
            // 'that', 'self', etc.)
            const propNamesAccessedFromIdentifier = method
                .getDescendantsOfKind(ts_morph_1.SyntaxKind.PropertyAccessExpression)
                .filter(is_property_access_with_obj_1.propertyAccessWithObjFilter(thisVarIdentifier))
                .map((p) => p.getName());
            propNamesAccessedFromIdentifier
                .forEach((propName) => propNames.add(propName));
        });
        return propNames;
    }, new Set());
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2UtanMtY2xhc3Nlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb252ZXJ0ZXIvYWRkLWNsYXNzLXByb3BlcnR5LWRlY2xhcmF0aW9ucy9wYXJzZS1qcy1jbGFzc2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHVDQUErSztBQUMvSyx5Q0FBcUM7QUFDckMsb0RBQXlEO0FBQ3pELGtGQUE2RTtBQUM3RSxxRkFBOEU7QUFDOUUsZ0ZBQTBFO0FBQzFFLHdGQUFxRjtBQUNyRixpRUFBeUM7QUFFekM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0ErQkc7QUFDSCxTQUFnQixjQUFjLENBQUUsWUFBcUI7SUFDcEQsZ0JBQU0sQ0FBQyxPQUFPLENBQUUsdUNBQXVDLENBQUUsQ0FBQztJQUMxRCxNQUFNLEtBQUssR0FBRyxZQUFZLENBQUMsY0FBYyxFQUFFLENBQUM7SUFFNUMsTUFBTSxTQUFTLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBRSxDQUFFLE9BQWtCLEVBQUUsSUFBZ0IsRUFBRyxFQUFFO1FBQzFFLGdCQUFNLENBQUMsS0FBSyxDQUFFLDRCQUE0QixJQUFJLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBRSxDQUFDO1FBRWpFLE1BQU0sV0FBVyxHQUFHLGdCQUFnQixDQUFFLElBQUksQ0FBRSxDQUFDO1FBQzdDLE9BQU8sT0FBTyxDQUFDLE1BQU0sQ0FBRSxXQUFXLENBQUUsQ0FBQztJQUN0QyxDQUFDLEVBQUUsRUFBRSxDQUFFLENBQUM7SUFFUixPQUFPLFNBQVMsQ0FBQztBQUNsQixDQUFDO0FBWkQsd0NBWUM7QUFHRDs7R0FFRztBQUNILFNBQVMsZ0JBQWdCLENBQUUsVUFBc0I7SUFDaEQsT0FBTyxVQUFVLENBQUMsVUFBVSxFQUFFLENBQUMsR0FBRyxDQUFFLFNBQVMsQ0FBQyxFQUFFO1FBQy9DLE1BQU0sU0FBUyxHQUFHLFNBQVMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUV0Qyxn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QixFQUFHLEVBQUUsQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLENBQUUsQ0FBQztRQUVyRSxrQkFBa0IsQ0FBQyxPQUFPLENBQUUsQ0FBRSxpQkFBeUIsRUFBRyxFQUFFO1lBQzNELHFFQUFxRTtZQUNyRSx3QkFBd0I7WUFDeEIsTUFBTSwrQkFBK0IsR0FBRyxNQUFNO2lCQUM1QyxvQkFBb0IsQ0FBRSxxQkFBVSxDQUFDLHdCQUF3QixDQUFFO2lCQUMzRCxNQUFNLENBQUUseURBQTJCLENBQUUsaUJBQWlCLENBQUUsQ0FBRTtpQkFDMUQsR0FBRyxDQUFFLENBQUUsQ0FBMkIsRUFBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFFLENBQUM7WUFFeEQsK0JBQStCO2lCQUM3QixPQUFPLENBQUUsQ0FBRSxRQUFnQixFQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFFLFFBQVEsQ0FBRSxDQUFFLENBQUM7UUFDaEUsQ0FBQyxDQUFFLENBQUM7UUFFSixPQUFPLFNBQVMsQ0FBQztJQUNsQixDQUFDLEVBQUUsSUFBSSxHQUFHLEVBQVUsQ0FBRSxDQUFDO0FBQ3hCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQcm9qZWN0LCB0cywgQ2xhc3NEZWNsYXJhdGlvbiwgQ2xhc3NJbnN0YW5jZVByb3BlcnR5VHlwZXMsIE1ldGhvZERlY2xhcmF0aW9uLCBQcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24sIFNvdXJjZUZpbGUsIFN5bnRheEtpbmQsIFZhcmlhYmxlRGVjbGFyYXRpb24gfSBmcm9tIFwidHMtbW9ycGhcIjtcbmltcG9ydCB7IEpzQ2xhc3MgfSBmcm9tIFwiLi9qcy1jbGFzc1wiO1xuaW1wb3J0IHsgZGlmZmVyZW5jZSwgdW5pb24gfSBmcm9tIFwiLi4vLi4vdXRpbC9zZXQtdXRpbHNcIjtcbmltcG9ydCB7IHBhcnNlRGVzdHJ1Y3R1cmVkUHJvcHMgfSBmcm9tIFwiLi4vLi4vdXRpbC9wYXJzZS1kZXN0cnVjdHVyZWQtcHJvcHNcIjtcbmltcG9ydCB7IHBhcnNlU3VwZXJjbGFzc05hbWVBbmRQYXRoIH0gZnJvbSBcIi4vcGFyc2Utc3VwZXJjbGFzcy1uYW1lLWFuZC1wYXRoXCI7XG5pbXBvcnQgeyBpc1RoaXNSZWZlcmVuY2luZ1ZhciB9IGZyb20gXCIuLi8uLi91dGlsL2lzLXRoaXMtcmVmZXJlbmNpbmctdmFyXCI7XG5pbXBvcnQgeyBwcm9wZXJ0eUFjY2Vzc1dpdGhPYmpGaWx0ZXIgfSBmcm9tIFwiLi4vLi4vdXRpbC9pcy1wcm9wZXJ0eS1hY2Nlc3Mtd2l0aC1vYmpcIjtcbmltcG9ydCBsb2dnZXIgZnJvbSBcIi4uLy4uL2xvZ2dlci9sb2dnZXJcIjtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGNsYXNzZXMgb3V0IG9mIGVhY2ggLmpzIGZpbGUgaW4gdGhlIFNvdXJjZUZpbGVzQ29sbGVjdGlvbiwgYW5kXG4gKiBmb3JtcyBhIHRyZWUgcmVwcmVzZW50aW5nIHRoZWlyIGhpZXJhcmNoeS5cbiAqXG4gKiAjIyBEZXNjcmlwdGlvbiBvZiBhbGdvcml0aG06XG4gKlxuICogRWFjaCBzb3VyY2UgZmlsZSBpcyBwYXJzZWQgdG8gZmluZCBhbGwgZmlsZS1sZXZlbCBjbGFzc2VzLiBUaGVpciBzdXBlcmNsYXNzZXNcbiAqIGFuZCBpbXBvcnQgcGF0aHMgZm9yIHRob3NlIHN1cGVyY2xhc3NlcyBhcmUgYWxzbyByZWNvcmRlZCB0byBmb3JtIGFuXG4gKiBhZGphY2VuY3kgbGlzdCBncmFwaCBvZiBjbGFzc2VzIGtleWVkIGJ5IHRoZWlyIGZpbGUgcGF0aC5cbiAqXG4gKiBFYWNoIGNsYXNzIGlzIGFsc28gcHJvY2Vzc2VkIHRvIGZpbmQgYW5kIHJlY29yZCBhbnkgcHJvcGVydHkgYWNjZXNzZXMgb2YgdGhlXG4gKiBgdGhpc2Agb2JqZWN0LiBGb3IgaW5zdGFuY2UsIGluIHRoZSBmb2xsb3dpbmcgY2xhc3MsIHRoZXJlIGFyZSAzXG4gKiBQcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb25zIHRoYXQgcHVsbCBmcm9tIHRoZSBgdGhpc2Agb2JqZWN0ICgnc29tZXRoaW5nMScsXG4gKiAnc29tZXRoaW5nMicsIGFuZCAnc29tZXRoaW5nMycpOlxuICpcbiAqICAgICBjbGFzcyBTb21ldGhpbmcge1xuICogICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAqICAgICAgICAgICAgIHRoaXMuc29tZXRoaW5nMSA9IDE7XG4gKiAgICAgICAgICAgICB0aGlzLnNvbWV0aGluZzIgPSAyO1xuICogICAgICAgICB9XG4gKlxuICogICAgICAgICBzb21lTWV0aG9kKCkge1xuICogICAgICAgICAgICAgY29uc29sZS5sb2coIHRoaXMuc29tZXRoaW5nMyApO1xuICpcbiAqICAgICAgICAgICAgIGNvbnNvbGUubG9nKCB3aW5kb3cubG9jYXRpb24gKTsgIC8vIDwtLSBub3QgYSBgdGhpc2AgUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uXG4gKiAgICAgICAgIH1cbiAqICAgICB9XG4gKlxuICogVGhlIHJldHVybmVkIGdyYXBoIHdpbGwgYmUgdXNlZCBsYXRlciB0byBkZXRlcm1pbmUgd2hpY2ggVFMgY2xhc3MgcHJvcGVydHlcbiAqIGRlZmluaXRpb25zIHNob3VsZCBiZSBwbGFjZWQgaW4gc3VwZXJjbGFzc2VzIHZzLiBzdWJjbGFzc2VzLiBQcm9wZXJ0aWVzIHVzZWRcbiAqIGJ5IGEgc3VwZXJjbGFzcyBhbmQgYSBzdWJjbGFzcyBzaG91bGQgb25seSBiZSBkZWZpbmVkIGluIHRoZSBzdXBlcmNsYXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VKc0NsYXNzZXMoIHRzQXN0UHJvamVjdDogUHJvamVjdCApOiBKc0NsYXNzW10ge1xuXHRsb2dnZXIudmVyYm9zZSggXCJQYXJzaW5nIEpTIGNsYXNzZXMgaW4gdGhlIGNvZGViYXNlLi4uXCIgKTtcblx0Y29uc3QgZmlsZXMgPSB0c0FzdFByb2plY3QuZ2V0U291cmNlRmlsZXMoKTtcblxuXHRjb25zdCBqc0NsYXNzZXMgPSBmaWxlcy5yZWR1Y2UoICggY2xhc3NlczogSnNDbGFzc1tdLCBmaWxlOiBTb3VyY2VGaWxlICkgPT4ge1xuXHRcdGxvZ2dlci5kZWJ1ZyggYFBhcnNpbmcgY2xhc3NlcyBpbiBmaWxlOiAke2ZpbGUuZ2V0RmlsZVBhdGgoKX1gICk7XG5cblx0XHRjb25zdCBmaWxlQ2xhc3NlcyA9IHBhcnNlRmlsZUNsYXNzZXMoIGZpbGUgKTtcblx0XHRyZXR1cm4gY2xhc3Nlcy5jb25jYXQoIGZpbGVDbGFzc2VzICk7XG5cdH0sIFtdICk7XG5cblx0cmV0dXJuIGpzQ2xhc3Nlcztcbn1cblxuXG4vKipcbiAqIFBhcnNlcyB0aGUgZmlsZS1sZXZlbCBjbGFzc2VzIG91dCBvZiB0aGUgZ2l2ZW4gYHNvdXJjZUZpbGVgLlxuICovXG5mdW5jdGlvbiBwYXJzZUZpbGVDbGFzc2VzKCBzb3VyY2VGaWxlOiBTb3VyY2VGaWxlICk6IEpzQ2xhc3NbXSB7XG5cdHJldHVybiBzb3VyY2VGaWxlLmdldENsYXNzZXMoKS5tYXAoIGZpbGVDbGFzcyA9PiB7XG5cdFx0Y29uc3QgY2xhc3NOYW1lID0gZmlsZUNsYXNzLmdldE5hbWUoKTtcblxuXHRcdGxvZ2dlci5kZWJ1ZyggYCAgUGFyc2luZyBjbGFzczogJHtjbGFzc05hbWV9YCApO1xuXG5cdFx0Y29uc3QgeyBzdXBlcmNsYXNzTmFtZSwgc3VwZXJjbGFzc1BhdGggfSA9IHBhcnNlU3VwZXJjbGFzc05hbWVBbmRQYXRoKCBzb3VyY2VGaWxlLCBmaWxlQ2xhc3MgKTtcblx0XHRjb25zdCBtZXRob2ROYW1lcyA9IGdldE1ldGhvZE5hbWVzKCBmaWxlQ2xhc3MgKTtcblx0XHRjb25zdCBwcm9wZXJ0eU5hbWVzID0gZ2V0UHJvcGVydHlOYW1lcyggZmlsZUNsYXNzICk7XG5cdFx0Y29uc3QgcHJvcGVydGllc01pbnVzTWV0aG9kcyA9IGRpZmZlcmVuY2UoIHByb3BlcnR5TmFtZXMsIG1ldGhvZE5hbWVzICk7ICAvLyByZW1vdmUgYW55IG1ldGhvZCBuYW1lcyBmcm9tIHRoaXMgU2V0XG5cblx0XHRyZXR1cm4gbmV3IEpzQ2xhc3MoIHtcblx0XHRcdHBhdGg6IHNvdXJjZUZpbGUuZ2V0RmlsZVBhdGgoKSxcblx0XHRcdG5hbWU6IGNsYXNzTmFtZSxcblx0XHRcdHN1cGVyY2xhc3NOYW1lLFxuXHRcdFx0c3VwZXJjbGFzc1BhdGgsXG5cdFx0XHRtZXRob2RzOiBtZXRob2ROYW1lcyxcblx0XHRcdHByb3BlcnRpZXM6IHByb3BlcnRpZXNNaW51c01ldGhvZHNcblx0XHR9ICk7XG5cdH0gKTtcbn1cblxuXG4vKipcbiAqIFBhcnNlcyB0aGUgbWV0aG9kIG5hbWVzIGZyb20gdGhlIGNsYXNzIGludG8gYSBTZXQgb2Ygc3RyaW5ncy5cbiAqL1xuZnVuY3Rpb24gZ2V0TWV0aG9kTmFtZXMoIGZpbGVDbGFzczogQ2xhc3NEZWNsYXJhdGlvbiApOiBTZXQ8c3RyaW5nPiB7XG5cdHJldHVybiBmaWxlQ2xhc3MuZ2V0TWV0aG9kcygpXG5cdFx0LnJlZHVjZSggKCBtZXRob2RzOiBTZXQ8c3RyaW5nPiwgbWV0aG9kOiBNZXRob2REZWNsYXJhdGlvbiApID0+IHtcblx0XHRcdHJldHVybiBtZXRob2RzLmFkZCggbWV0aG9kLmdldE5hbWUoKSApO1xuXHRcdH0sIG5ldyBTZXQ8c3RyaW5nPigpICk7XG59XG5cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGxpc3Qgb2YgcHJvcGVydHlOYW1lcyB1c2VkIGluIHRoZSBjbGFzcy4gVGhpcyBtYXkgYWxzbyBpbmNsdWRlXG4gKiBtZXRob2QgbmFtZXMgKHdoaWNoIGFyZSB0ZWNobmljYWxseSBwcm9wZXJ0aWVzKSwgd2hpY2ggd2UnbGwgZmlsdGVyIG91dCBsYXRlci5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcGVydHlOYW1lcyggZmlsZUNsYXNzOiBDbGFzc0RlY2xhcmF0aW9uICkge1xuXHRjb25zdCBleGlzdGluZ1Byb3BlcnR5RGVjbGFyYXRpb25zID0gcGFyc2VQcm9wZXJ0eURlY2xhcmF0aW9ucyggZmlsZUNsYXNzICk7ICAvLyBpbiBjYXNlIHdlIGFyZSBhY3R1YWxseSBwYXJzaW5nIGEgVHlwZVNjcmlwdCBjbGFzcyB3aXRoIGV4aXN0aW5nIGRlY2xhcmF0aW9uc1xuXHRjb25zdCBwcm9wZXJ0eUFjY2Vzc2VzID0gcGFyc2VQcm9wZXJ0eUFjY2Vzc2VzKCBmaWxlQ2xhc3MgKTtcblx0Y29uc3QgZGVzdHJ1Y3R1cmluZ1VzZXNPZlByb3BlcnRpZXMgPSBwYXJzZURlc3RydWN0dXJpbmdUaGlzQXNzaWdubWVudHMoIGZpbGVDbGFzcyApO1xuXHRjb25zdCBwcm9wZXJ0eUFjY2Vzc2VzT2ZUaGlzQXNzaWduZWRWYXJzID0gcGFyc2VQcm9wZXJ0eUFjY2Vzc2VzT2ZUaGlzQXNzaWduZWRWYXJzKCBmaWxlQ2xhc3MgKTtcblxuXHRyZXR1cm4gdW5pb24oXG5cdFx0ZXhpc3RpbmdQcm9wZXJ0eURlY2xhcmF0aW9ucyxcblx0XHRwcm9wZXJ0eUFjY2Vzc2VzLFxuXHRcdGRlc3RydWN0dXJpbmdVc2VzT2ZQcm9wZXJ0aWVzLFxuXHRcdHByb3BlcnR5QWNjZXNzZXNPZlRoaXNBc3NpZ25lZFZhcnNcblx0KTtcbn1cblxuXG4vKipcbiAqIEluIHRoZSBjYXNlIHRoYXQgdGhlIHV0aWxpdHkgaXMgYWN0dWFsbHkgcGFyc2luZyBUeXBlU2NyaXB0IGNsYXNzZXMgd2l0aFxuICogZXhpc3RpbmcgcHJvcGVydHkgZGVjbGFyYXRpb25zLCB3ZSB3YW50IHRvIGtub3cgYWJvdXQgdGhlc2Ugc28gd2UgZG9uJ3RcbiAqIGFjY2lkZW50YWxseSB3cml0ZSBpbiBuZXcgb25lcyBvZiB0aGUgc2FtZSBuYW1lLlxuICovXG5mdW5jdGlvbiBwYXJzZVByb3BlcnR5RGVjbGFyYXRpb25zKCBmaWxlQ2xhc3M6IENsYXNzRGVjbGFyYXRpb24gKTogU2V0PHN0cmluZz4ge1xuXHRyZXR1cm4gZmlsZUNsYXNzLmdldEluc3RhbmNlUHJvcGVydGllcygpXG5cdFx0LnJlZHVjZSggKCBwcm9wczogU2V0PHN0cmluZz4sIHByb3A6IENsYXNzSW5zdGFuY2VQcm9wZXJ0eVR5cGVzICkgPT4ge1xuXHRcdFx0Y29uc3QgcHJvcE5hbWUgPSBwcm9wLmdldE5hbWUoKTtcblx0XHRcdHJldHVybiBwcm9wTmFtZSA/IHByb3BzLmFkZCggcHJvcE5hbWUgKSA6IHByb3BzOyAgLy8gZG9uJ3QgYWRkIHVubmFtZWQgcHJvcGVydGllcyAobm90IHN1cmUgaG93IHdlIHdvdWxkIGhhdmUgb25lIG9mIHRob3NlLCBidXQgc2VlbXMgaXRzIHBvc3NpYmxlIGFjY29yZGluZyB0byB0aGUgVHNTaW1wbGVBc3QgdHlwZXMpXG5cdFx0fSwgbmV3IFNldDxzdHJpbmc+KCkgKTtcbn1cblxuXG4vKipcbiAqIFBhcnNlcyB0aGUgcHJvcGVydHkgbmFtZXMgb2YgYHRoaXNgIFByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbnMuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgIHRoaXMuc29tZXRoaW5nID0gNDI7XG4gKiAgICAgY29uc29sZS5sb2coIHRoaXMuc29tZXRoaW5nMiApO1xuICpcbiAqICAgICBjb25zdCB7IGRlc3RydWN0dXJlZDEsIGRlc3RydWN0dXJlZDIgfSA9IHRoaXM7XG4gKlxuICogTWV0aG9kIHJldHVybnM6XG4gKlxuICogICAgU2V0KCBbICdzb21ldGhpbmcnLCAnc29tZXRoaW5nMicsICdkZXN0cnVjdHVyZWQxJywgJ2Rlc3RydWN0dXJlZDInIF0gKVxuICovXG5mdW5jdGlvbiBwYXJzZVByb3BlcnR5QWNjZXNzZXMoIGZpbGVDbGFzczogQ2xhc3NEZWNsYXJhdGlvbiApOiBTZXQ8c3RyaW5nPiB7XG5cdC8vIEZpcnN0LCBmaW5kIGFsbCBvZiB0aGUgYHRoaXMuc29tZXRoaW5nYCBwcm9wZXJ0aWVzXG5cdGNvbnN0IHRoaXNQcm9wcyA9IGZpbGVDbGFzc1xuXHRcdC5nZXREZXNjZW5kYW50c09mS2luZCggU3ludGF4S2luZC5Qcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24gKVxuXHRcdC5maWx0ZXIoICggcHJvcDogUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uICkgPT4gcHJvcC5nZXRFeHByZXNzaW9uKCkuZ2V0S2luZCgpID09PSBTeW50YXhLaW5kLlRoaXNLZXl3b3JkICk7XG5cblx0Y29uc3QgcHJvcE5hbWVzU2V0ID0gdGhpc1Byb3BzXG5cdFx0LnJlZHVjZSggKCBwcm9wczogU2V0PHN0cmluZz4sIHByb3A6IFByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbiApID0+IHtcblx0XHRcdHJldHVybiBwcm9wcy5hZGQoIHByb3AuZ2V0TmFtZSgpICk7XG5cdFx0fSwgbmV3IFNldDxzdHJpbmc+KCkgKTtcblxuXHRyZXR1cm4gcHJvcE5hbWVzU2V0O1xufVxuXG5cbi8qKlxuICogUGFyc2VzIGFueSBvYmplY3QgZGVzdHJ1Y3R1cmluZyBzdGF0ZW1lbnRzIG9mIHRoZSBmb3JtOlxuICpcbiAqICAgICB2YXIgeyBhLCBiIH0gPSB0aGlzO1xuICpcbiAqIEFuZCByZXR1cm5zIFNldCggWyAnYScsICdiJyBdICkgaW4gdGhpcyBjYXNlLlxuICovXG5mdW5jdGlvbiBwYXJzZURlc3RydWN0dXJpbmdUaGlzQXNzaWdubWVudHMoIGZpbGVDbGFzczogQ2xhc3NEZWNsYXJhdGlvbiApOiBTZXQ8c3RyaW5nPiB7XG5cdC8vIFNlY29uZCwgZmluZCBhbnkgYHZhciB7IGEsIGIgfSA9IHRoaXNgIHN0YXRlbWVudHNcblx0Y29uc3QgZGVzdHJ1Y3R1cmVkUHJvcHMgPSBmaWxlQ2xhc3Ncblx0XHQuZ2V0RGVzY2VuZGFudHNPZktpbmQoIFN5bnRheEtpbmQuVmFyaWFibGVEZWNsYXJhdGlvbiApXG5cdFx0LmZpbHRlciggKCB2YXJEZWM6IFZhcmlhYmxlRGVjbGFyYXRpb24gKSA9PiB7XG5cdFx0XHRyZXR1cm4gdmFyRGVjLmNvbXBpbGVyTm9kZS5uYW1lLmtpbmQgPT09IFN5bnRheEtpbmQuT2JqZWN0QmluZGluZ1BhdHRlcm47XG5cdFx0fSApO1xuXG5cdHJldHVybiBkZXN0cnVjdHVyZWRQcm9wc1xuXHRcdC5yZWR1Y2UoICggcHJvcE5hbWVzOiBTZXQ8c3RyaW5nPiwgdmFyRGVjOiBWYXJpYWJsZURlY2xhcmF0aW9uICkgPT4ge1xuXHRcdFx0Y29uc3QgZGVzdHJ1Y3R1cmVkUHJvcE5hbWVzID0gcGFyc2VEZXN0cnVjdHVyZWRQcm9wcyggdmFyRGVjLmNvbXBpbGVyTm9kZS5uYW1lIGFzIHRzLk9iamVjdEJpbmRpbmdQYXR0ZXJuICk7XG5cdFx0XHRkZXN0cnVjdHVyZWRQcm9wTmFtZXMuZm9yRWFjaCggcHJvcE5hbWUgPT4gcHJvcE5hbWVzLmFkZCggcHJvcE5hbWUgKSApO1xuXG5cdFx0XHRyZXR1cm4gcHJvcE5hbWVzO1xuXHRcdH0sIG5ldyBTZXQ8c3RyaW5nPigpICk7XG59XG5cblxuLyoqXG4gKiBQYXJzZXMgcHJvcGVydHkgYWNjZXNzZXMgb2YgdmFyaWFibGVzIHRoYXQgYXJlIGFzc2lnbmVkIHRvIHRoZSBgdGhpc2BcbiAqIGtleXdvcmQuXG4gKlxuICogRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIHZhciB0aGF0ID0gdGhpcztcbiAqXG4gKiAgICAgdGhhdC5zb21lUHJvcDEgPSAxO1xuICogICAgIHRoYXQuc29tZVByb3AyID0gMjtcbiAqXG4gKiBJbiB0aGUgYWJvdmUgY29kZSwgdGhlIFNldCggWyAnc29tZVByb3AxJywgJ3NvbWVQcm9wMicgXSApIGlzIHJldHVybmVkXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUHJvcGVydHlBY2Nlc3Nlc09mVGhpc0Fzc2lnbmVkVmFycyhcblx0ZmlsZUNsYXNzOiBDbGFzc0RlY2xhcmF0aW9uXG4pOiBTZXQ8c3RyaW5nPiB7XG5cdGNvbnN0IG1ldGhvZHMgPSBmaWxlQ2xhc3MuZ2V0TWV0aG9kcygpO1xuXG5cdHJldHVybiBtZXRob2RzLnJlZHVjZSggKCBwcm9wTmFtZXM6IFNldDxzdHJpbmc+LCBtZXRob2Q6IE1ldGhvZERlY2xhcmF0aW9uICkgPT4ge1xuXHRcdGNvbnN0IHRoaXNWYXJEZWNsYXJhdGlvbnMgPSBtZXRob2Rcblx0XHRcdC5nZXREZXNjZW5kYW50c09mS2luZCggU3ludGF4S2luZC5WYXJpYWJsZURlY2xhcmF0aW9uIClcblx0XHRcdC5maWx0ZXIoIGlzVGhpc1JlZmVyZW5jaW5nVmFyICk7XG5cblx0XHQvLyBHZXQgdGhlIGFycmF5IG9mIGlkZW50aWZpZXJzIGFzc2lnbmVkIHRvIGB0aGlzYC4gRXg6IFsgJ3RoYXQnLCAnc2VsZicgXVxuXHRcdGNvbnN0IHRoaXNWYXJJZGVudGlmaWVycyA9IHRoaXNWYXJEZWNsYXJhdGlvbnNcblx0XHRcdC5tYXAoICggdGhpc1ZhckRlYzogVmFyaWFibGVEZWNsYXJhdGlvbiApID0+IHRoaXNWYXJEZWMuZ2V0TmFtZSgpICk7XG5cblx0XHR0aGlzVmFySWRlbnRpZmllcnMuZm9yRWFjaCggKCB0aGlzVmFySWRlbnRpZmllcjogc3RyaW5nICkgPT4ge1xuXHRcdFx0Ly8gR2V0IHRoZSBwcm9wZXJ0aWVzIGFjY2Vzc2VkIGZyb20gdGhlIGB0aGlzYCBpZGVudGlmaWVycyAoaS5lLiBmcm9tXG5cdFx0XHQvLyAndGhhdCcsICdzZWxmJywgZXRjLilcblx0XHRcdGNvbnN0IHByb3BOYW1lc0FjY2Vzc2VkRnJvbUlkZW50aWZpZXIgPSBtZXRob2Rcblx0XHRcdFx0LmdldERlc2NlbmRhbnRzT2ZLaW5kKCBTeW50YXhLaW5kLlByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbiApXG5cdFx0XHRcdC5maWx0ZXIoIHByb3BlcnR5QWNjZXNzV2l0aE9iakZpbHRlciggdGhpc1ZhcklkZW50aWZpZXIgKSApXG5cdFx0XHRcdC5tYXAoICggcDogUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uICkgPT4gcC5nZXROYW1lKCkgKTtcblxuXHRcdFx0cHJvcE5hbWVzQWNjZXNzZWRGcm9tSWRlbnRpZmllclxuXHRcdFx0XHQuZm9yRWFjaCggKCBwcm9wTmFtZTogc3RyaW5nICkgPT4gcHJvcE5hbWVzLmFkZCggcHJvcE5hbWUgKSApO1xuXHRcdH0gKTtcblxuXHRcdHJldHVybiBwcm9wTmFtZXM7XG5cdH0sIG5ldyBTZXQ8c3RyaW5nPigpICk7XG59Il19