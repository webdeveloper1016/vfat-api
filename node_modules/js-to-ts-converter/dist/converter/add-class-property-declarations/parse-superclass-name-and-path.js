"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseSuperclassNameAndPath = void 0;
const is_valid_identifier_1 = require("../../util/is-valid-identifier");
const find_import_for_identifier_1 = require("../../util/find-import-for-identifier");
const resolve = require('resolve');
const TraceError = require('trace-error');
/**
 * Given a file and ClassDeclaration, finds the name of the superclass and the
 * full path to the module (file) that hosts the superclass.
 *
 * `superclass` and `superclassPath` in the return object will be `null` if
 * there is no superclass.
 */
function parseSuperclassNameAndPath(file, fileClass) {
    let superclassName;
    let superclassPath;
    const heritage = fileClass.getExtends();
    if (heritage) {
        superclassName = heritage.getExpression().getText();
        // Confirm that the superclass is an identifier rather than an
        // expression. It would be a bit much to try to understand expressions
        // as a class's 'extends', so just ignore these for now.
        // Example of ignored class extends:
        //
        //    class MyClass extends Mixin.mix( MixinClass1, MixinClass2 )
        //
        if (!is_valid_identifier_1.isValidIdentifier(superclassName)) {
            superclassName = undefined; // superclass was not a valid identifier
        }
        else if (!!file.getClass(superclassName)) {
            superclassPath = file.getFilePath();
        }
        else {
            superclassPath = findImportPathForIdentifier(file, superclassName);
        }
    }
    return {
        superclassName,
        superclassPath: superclassPath && superclassPath.replace(/\\/g, '/') // normalize backslashes on Windows to forward slashes so we can compare directories with the paths that ts-morph produces
    };
}
exports.parseSuperclassNameAndPath = parseSuperclassNameAndPath;
/**
 * Finds the absolute path for the import with the given `identifier`.
 *
 * For example, if we were looking for the identifier 'MyClass' in the following
 * list of imports:
 *
 *     import { Something } from './somewhere';
 *     import { MyClass } from './my-class';
 *
 * Then the method would return '/absolute/path/to/my-class.js';
 *
 * If there is no import for `identifier`, the method returns `undefined`.
 */
function findImportPathForIdentifier(sourceFile, identifier) {
    const importWithIdentifier = find_import_for_identifier_1.findImportForIdentifier(sourceFile, identifier);
    if (importWithIdentifier) {
        const moduleSpecifier = importWithIdentifier.getModuleSpecifier().getLiteralValue();
        if (!moduleSpecifier.startsWith('.')) {
            // if the import path isn't relative (i.e. doesn't start with './'
            // or '../'), then it must be in node_modules. Return `undefined` to
            // represent that. We don't want to parse node_modules, and we
            // should be able to migrate the codebase without node_modules even
            // being installed.
            return undefined;
        }
        // If it's a relative import, return the absolute path to the module,
        // based on the source file that the import was found
        const basedir = sourceFile.getDirectoryPath();
        try {
            return resolve.sync(moduleSpecifier, {
                basedir,
                extensions: ['.ts', '.js']
            });
        }
        catch (error) {
            throw new TraceError(`
				An error occurred while trying to resolve the absolute path to
				the import of identifier '${identifier}' in source file:
				    '${sourceFile.getFilePath()}'
				    
				Was looking at the import with text:
				    ${importWithIdentifier.getText()}   
			`.trim().replace(/^\t*/gm, ''), error);
        }
    }
    // Nothing found, return undefined
    return undefined;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2Utc3VwZXJjbGFzcy1uYW1lLWFuZC1wYXRoLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbnZlcnRlci9hZGQtY2xhc3MtcHJvcGVydHktZGVjbGFyYXRpb25zL3BhcnNlLXN1cGVyY2xhc3MtbmFtZS1hbmQtcGF0aC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSx3RUFBbUU7QUFFbkUsc0ZBQWdGO0FBQ2hGLE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBRSxTQUFTLENBQUUsQ0FBQztBQUNyQyxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUUsYUFBYSxDQUFFLENBQUM7QUFFNUM7Ozs7OztHQU1HO0FBQ0gsU0FBZ0IsMEJBQTBCLENBQ3pDLElBQWdCLEVBQ2hCLFNBQTJCO0lBSzNCLElBQUksY0FBa0MsQ0FBQztJQUN2QyxJQUFJLGNBQWtDLENBQUM7SUFFdkMsTUFBTSxRQUFRLEdBQUcsU0FBUyxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQ3hDLElBQUksUUFBUSxFQUFHO1FBQ2QsY0FBYyxHQUFHLFFBQVEsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUVwRCw4REFBOEQ7UUFDOUQsc0VBQXNFO1FBQ3RFLHdEQUF3RDtRQUN4RCxvQ0FBb0M7UUFDcEMsRUFBRTtRQUNGLGlFQUFpRTtRQUNqRSxFQUFFO1FBQ0YsSUFBSSxDQUFDLHVDQUFpQixDQUFFLGNBQWMsQ0FBRSxFQUFHO1lBQzFDLGNBQWMsR0FBRyxTQUFTLENBQUMsQ0FBRSx3Q0FBd0M7U0FFckU7YUFBTSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFFLGNBQWMsQ0FBRSxFQUFHO1lBQzlDLGNBQWMsR0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7U0FFcEM7YUFBTTtZQUNOLGNBQWMsR0FBRywyQkFBMkIsQ0FBRSxJQUFJLEVBQUUsY0FBYyxDQUFFLENBQUM7U0FDckU7S0FDRDtJQUVELE9BQU87UUFDTixjQUFjO1FBQ2QsY0FBYyxFQUFFLGNBQWMsSUFBSSxjQUFjLENBQUMsT0FBTyxDQUFFLEtBQUssRUFBRSxHQUFHLENBQUUsQ0FBRSwwSEFBMEg7S0FDbE0sQ0FBQztBQUNILENBQUM7QUFwQ0QsZ0VBb0NDO0FBR0Q7Ozs7Ozs7Ozs7OztHQVlHO0FBQ0gsU0FBUywyQkFBMkIsQ0FDbkMsVUFBc0IsRUFDdEIsVUFBa0I7SUFFbEIsTUFBTSxvQkFBb0IsR0FBRyxvREFBdUIsQ0FBRSxVQUFVLEVBQUUsVUFBVSxDQUFFLENBQUM7SUFFL0UsSUFBSSxvQkFBb0IsRUFBRztRQUMxQixNQUFNLGVBQWUsR0FBRyxvQkFBb0IsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBRXBGLElBQUksQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFFLEdBQUcsQ0FBRSxFQUFHO1lBQ3hDLGtFQUFrRTtZQUNsRSxvRUFBb0U7WUFDcEUsOERBQThEO1lBQzlELG1FQUFtRTtZQUNuRSxtQkFBbUI7WUFDbkIsT0FBTyxTQUFTLENBQUM7U0FDakI7UUFFRCxxRUFBcUU7UUFDckUscURBQXFEO1FBQ3JELE1BQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBQzlDLElBQUk7WUFDSCxPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUUsZUFBZSxFQUFFO2dCQUNyQyxPQUFPO2dCQUNQLFVBQVUsRUFBRSxDQUFFLEtBQUssRUFBRSxLQUFLLENBQUU7YUFDNUIsQ0FBRSxDQUFDO1NBRUo7UUFBQyxPQUFPLEtBQUssRUFBRztZQUNoQixNQUFNLElBQUksVUFBVSxDQUFFOztnQ0FFTyxVQUFVO1dBQy9CLFVBQVUsQ0FBQyxXQUFXLEVBQUU7OztVQUd6QixvQkFBb0IsQ0FBQyxPQUFPLEVBQUU7SUFDcEMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxPQUFPLENBQUUsUUFBUSxFQUFFLEVBQUUsQ0FBRSxFQUFFLEtBQUssQ0FBRSxDQUFDO1NBQzFDO0tBQ0Q7SUFFRCxrQ0FBa0M7SUFDbEMsT0FBTyxTQUFTLENBQUM7QUFDbEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzVmFsaWRJZGVudGlmaWVyIH0gZnJvbSBcIi4uLy4uL3V0aWwvaXMtdmFsaWQtaWRlbnRpZmllclwiO1xuaW1wb3J0IHsgQ2xhc3NEZWNsYXJhdGlvbiwgU291cmNlRmlsZSB9IGZyb20gXCJ0cy1tb3JwaFwiO1xuaW1wb3J0IHsgZmluZEltcG9ydEZvcklkZW50aWZpZXIgfSBmcm9tIFwiLi4vLi4vdXRpbC9maW5kLWltcG9ydC1mb3ItaWRlbnRpZmllclwiO1xuY29uc3QgcmVzb2x2ZSA9IHJlcXVpcmUoICdyZXNvbHZlJyApO1xuY29uc3QgVHJhY2VFcnJvciA9IHJlcXVpcmUoICd0cmFjZS1lcnJvcicgKTtcblxuLyoqXG4gKiBHaXZlbiBhIGZpbGUgYW5kIENsYXNzRGVjbGFyYXRpb24sIGZpbmRzIHRoZSBuYW1lIG9mIHRoZSBzdXBlcmNsYXNzIGFuZCB0aGVcbiAqIGZ1bGwgcGF0aCB0byB0aGUgbW9kdWxlIChmaWxlKSB0aGF0IGhvc3RzIHRoZSBzdXBlcmNsYXNzLlxuICpcbiAqIGBzdXBlcmNsYXNzYCBhbmQgYHN1cGVyY2xhc3NQYXRoYCBpbiB0aGUgcmV0dXJuIG9iamVjdCB3aWxsIGJlIGBudWxsYCBpZlxuICogdGhlcmUgaXMgbm8gc3VwZXJjbGFzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU3VwZXJjbGFzc05hbWVBbmRQYXRoKFxuXHRmaWxlOiBTb3VyY2VGaWxlLFxuXHRmaWxlQ2xhc3M6IENsYXNzRGVjbGFyYXRpb25cbik6IHtcblx0c3VwZXJjbGFzc05hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcblx0c3VwZXJjbGFzc1BhdGg6IHN0cmluZyB8IHVuZGVmaW5lZDtcbn0ge1xuXHRsZXQgc3VwZXJjbGFzc05hbWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcblx0bGV0IHN1cGVyY2xhc3NQYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cblx0Y29uc3QgaGVyaXRhZ2UgPSBmaWxlQ2xhc3MuZ2V0RXh0ZW5kcygpO1xuXHRpZiggaGVyaXRhZ2UgKSB7XG5cdFx0c3VwZXJjbGFzc05hbWUgPSBoZXJpdGFnZS5nZXRFeHByZXNzaW9uKCkuZ2V0VGV4dCgpO1xuXG5cdFx0Ly8gQ29uZmlybSB0aGF0IHRoZSBzdXBlcmNsYXNzIGlzIGFuIGlkZW50aWZpZXIgcmF0aGVyIHRoYW4gYW5cblx0XHQvLyBleHByZXNzaW9uLiBJdCB3b3VsZCBiZSBhIGJpdCBtdWNoIHRvIHRyeSB0byB1bmRlcnN0YW5kIGV4cHJlc3Npb25zXG5cdFx0Ly8gYXMgYSBjbGFzcydzICdleHRlbmRzJywgc28ganVzdCBpZ25vcmUgdGhlc2UgZm9yIG5vdy5cblx0XHQvLyBFeGFtcGxlIG9mIGlnbm9yZWQgY2xhc3MgZXh0ZW5kczpcblx0XHQvL1xuXHRcdC8vICAgIGNsYXNzIE15Q2xhc3MgZXh0ZW5kcyBNaXhpbi5taXgoIE1peGluQ2xhc3MxLCBNaXhpbkNsYXNzMiApXG5cdFx0Ly9cblx0XHRpZiggIWlzVmFsaWRJZGVudGlmaWVyKCBzdXBlcmNsYXNzTmFtZSApICkge1xuXHRcdFx0c3VwZXJjbGFzc05hbWUgPSB1bmRlZmluZWQ7ICAvLyBzdXBlcmNsYXNzIHdhcyBub3QgYSB2YWxpZCBpZGVudGlmaWVyXG5cblx0XHR9IGVsc2UgaWYoICEhZmlsZS5nZXRDbGFzcyggc3VwZXJjbGFzc05hbWUgKSApIHtcblx0XHRcdHN1cGVyY2xhc3NQYXRoID0gZmlsZS5nZXRGaWxlUGF0aCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHN1cGVyY2xhc3NQYXRoID0gZmluZEltcG9ydFBhdGhGb3JJZGVudGlmaWVyKCBmaWxlLCBzdXBlcmNsYXNzTmFtZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7XG5cdFx0c3VwZXJjbGFzc05hbWUsXG5cdFx0c3VwZXJjbGFzc1BhdGg6IHN1cGVyY2xhc3NQYXRoICYmIHN1cGVyY2xhc3NQYXRoLnJlcGxhY2UoIC9cXFxcL2csICcvJyApICAvLyBub3JtYWxpemUgYmFja3NsYXNoZXMgb24gV2luZG93cyB0byBmb3J3YXJkIHNsYXNoZXMgc28gd2UgY2FuIGNvbXBhcmUgZGlyZWN0b3JpZXMgd2l0aCB0aGUgcGF0aHMgdGhhdCB0cy1tb3JwaCBwcm9kdWNlc1xuXHR9O1xufVxuXG5cbi8qKlxuICogRmluZHMgdGhlIGFic29sdXRlIHBhdGggZm9yIHRoZSBpbXBvcnQgd2l0aCB0aGUgZ2l2ZW4gYGlkZW50aWZpZXJgLlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiB3ZSB3ZXJlIGxvb2tpbmcgZm9yIHRoZSBpZGVudGlmaWVyICdNeUNsYXNzJyBpbiB0aGUgZm9sbG93aW5nXG4gKiBsaXN0IG9mIGltcG9ydHM6XG4gKlxuICogICAgIGltcG9ydCB7IFNvbWV0aGluZyB9IGZyb20gJy4vc29tZXdoZXJlJztcbiAqICAgICBpbXBvcnQgeyBNeUNsYXNzIH0gZnJvbSAnLi9teS1jbGFzcyc7XG4gKlxuICogVGhlbiB0aGUgbWV0aG9kIHdvdWxkIHJldHVybiAnL2Fic29sdXRlL3BhdGgvdG8vbXktY2xhc3MuanMnO1xuICpcbiAqIElmIHRoZXJlIGlzIG5vIGltcG9ydCBmb3IgYGlkZW50aWZpZXJgLCB0aGUgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbXBvcnRQYXRoRm9ySWRlbnRpZmllcihcblx0c291cmNlRmlsZTogU291cmNlRmlsZSxcblx0aWRlbnRpZmllcjogc3RyaW5nXG4pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuXHRjb25zdCBpbXBvcnRXaXRoSWRlbnRpZmllciA9IGZpbmRJbXBvcnRGb3JJZGVudGlmaWVyKCBzb3VyY2VGaWxlLCBpZGVudGlmaWVyICk7XG5cblx0aWYoIGltcG9ydFdpdGhJZGVudGlmaWVyICkge1xuXHRcdGNvbnN0IG1vZHVsZVNwZWNpZmllciA9IGltcG9ydFdpdGhJZGVudGlmaWVyLmdldE1vZHVsZVNwZWNpZmllcigpLmdldExpdGVyYWxWYWx1ZSgpO1xuXG5cdFx0aWYoICFtb2R1bGVTcGVjaWZpZXIuc3RhcnRzV2l0aCggJy4nICkgKSB7XG5cdFx0XHQvLyBpZiB0aGUgaW1wb3J0IHBhdGggaXNuJ3QgcmVsYXRpdmUgKGkuZS4gZG9lc24ndCBzdGFydCB3aXRoICcuLydcblx0XHRcdC8vIG9yICcuLi8nKSwgdGhlbiBpdCBtdXN0IGJlIGluIG5vZGVfbW9kdWxlcy4gUmV0dXJuIGB1bmRlZmluZWRgIHRvXG5cdFx0XHQvLyByZXByZXNlbnQgdGhhdC4gV2UgZG9uJ3Qgd2FudCB0byBwYXJzZSBub2RlX21vZHVsZXMsIGFuZCB3ZVxuXHRcdFx0Ly8gc2hvdWxkIGJlIGFibGUgdG8gbWlncmF0ZSB0aGUgY29kZWJhc2Ugd2l0aG91dCBub2RlX21vZHVsZXMgZXZlblxuXHRcdFx0Ly8gYmVpbmcgaW5zdGFsbGVkLlxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBJZiBpdCdzIGEgcmVsYXRpdmUgaW1wb3J0LCByZXR1cm4gdGhlIGFic29sdXRlIHBhdGggdG8gdGhlIG1vZHVsZSxcblx0XHQvLyBiYXNlZCBvbiB0aGUgc291cmNlIGZpbGUgdGhhdCB0aGUgaW1wb3J0IHdhcyBmb3VuZFxuXHRcdGNvbnN0IGJhc2VkaXIgPSBzb3VyY2VGaWxlLmdldERpcmVjdG9yeVBhdGgoKTtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHJlc29sdmUuc3luYyggbW9kdWxlU3BlY2lmaWVyLCB7XG5cdFx0XHRcdGJhc2VkaXIsXG5cdFx0XHRcdGV4dGVuc2lvbnM6IFsgJy50cycsICcuanMnIF1cblx0XHRcdH0gKTtcblxuXHRcdH0gY2F0Y2goIGVycm9yICkge1xuXHRcdFx0dGhyb3cgbmV3IFRyYWNlRXJyb3IoIGBcblx0XHRcdFx0QW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgdHJ5aW5nIHRvIHJlc29sdmUgdGhlIGFic29sdXRlIHBhdGggdG9cblx0XHRcdFx0dGhlIGltcG9ydCBvZiBpZGVudGlmaWVyICcke2lkZW50aWZpZXJ9JyBpbiBzb3VyY2UgZmlsZTpcblx0XHRcdFx0ICAgICcke3NvdXJjZUZpbGUuZ2V0RmlsZVBhdGgoKX0nXG5cdFx0XHRcdCAgICBcblx0XHRcdFx0V2FzIGxvb2tpbmcgYXQgdGhlIGltcG9ydCB3aXRoIHRleHQ6XG5cdFx0XHRcdCAgICAke2ltcG9ydFdpdGhJZGVudGlmaWVyLmdldFRleHQoKX0gICBcblx0XHRcdGAudHJpbSgpLnJlcGxhY2UoIC9eXFx0Ki9nbSwgJycgKSwgZXJyb3IgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBOb3RoaW5nIGZvdW5kLCByZXR1cm4gdW5kZWZpbmVkXG5cdHJldHVybiB1bmRlZmluZWQ7XG59Il19