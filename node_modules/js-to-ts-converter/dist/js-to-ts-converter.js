"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertJsToTsSync = exports.convertJsToTs = void 0;
const path = __importStar(require("path"));
const create_ts_morph_project_1 = require("./create-ts-morph-project");
const convert_1 = require("./converter/convert");
const logger_1 = __importDefault(require("./logger/logger"));
/**
 * Asynchronously converts the JavaScript files under the given `sourceFilesPath`
 * to TypeScript files.
 *
 * @param sourceFilesPath The path to the source files to convert
 * @param [options]
 * @param [options.indentationText] The text used to indent new class property
 *   declarations.
 * @param [options.logLevel] The level of logging to show on the console.
 *   One of: 'debug', 'verbose', 'info', 'warn', 'error'
 * @param [options.includePatterns] Glob patterns to include files.
 * @param [options.excludePatterns] Glob patterns to exclude files.
 */
async function convertJsToTs(sourceFilesPath, options = {}) {
    const convertedTsAstProject = doConvert(sourceFilesPath, options);
    // Save output files
    return convertedTsAstProject.save();
}
exports.convertJsToTs = convertJsToTs;
/**
 * Synchronously converts the JavaScript files under the given `sourceFilesPath`
 * to TypeScript files.
 *
 * @param sourceFilesPath The path to the source files to convert
 * @param [options]
 * @param [options.indentationText] The text used to indent new class property
 *   declarations.
 * @param [options.logLevel] The level of logging to show on the console.
 *   One of: 'debug', 'verbose', 'info', 'warn', 'error'
 * @param [options.includePatterns] Glob patterns to include files.
 * @param [options.excludePatterns] Glob patterns to exclude files.
 */
function convertJsToTsSync(sourceFilesPath, options = {}) {
    const convertedTsAstProject = doConvert(sourceFilesPath, options);
    // Save output files
    convertedTsAstProject.saveSync();
}
exports.convertJsToTsSync = convertJsToTsSync;
/**
 * Performs the actual conversion given a `sourceFilesPath`, and returning a
 * `ts-morph` Project with the converted source files.
 *
 * @param sourceFilesPath The path to the source files to convert
 * @param [options]
 * @param [options.indentationText] The text used to indent new class property
 *   declarations.
 * @param [options.logLevel] The level of logging to show on the console.
 *   One of: 'debug', 'verbose', 'info', 'warn', 'error'
 * @param [options.includePatterns] Glob patterns to include files.
 * @param [options.excludePatterns] Glob patterns to exclude files.
 */
function doConvert(sourceFilesPath, options = {}) {
    logger_1.default.setLogLevel(options.logLevel || 'verbose');
    const absolutePath = path.resolve(sourceFilesPath);
    const tsAstProject = create_ts_morph_project_1.createTsMorphProject(absolutePath, options);
    return convert_1.convert(tsAstProject);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianMtdG8tdHMtY29udmVydGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2pzLXRvLXRzLWNvbnZlcnRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQTZCO0FBQzdCLHVFQUFpRTtBQUNqRSxpREFBOEM7QUFHOUMsNkRBQXFDO0FBU3JDOzs7Ozs7Ozs7Ozs7R0FZRztBQUNJLEtBQUssVUFBVSxhQUFhLENBQ2xDLGVBQXVCLEVBQ3ZCLFVBQWtDLEVBQUU7SUFFcEMsTUFBTSxxQkFBcUIsR0FBRyxTQUFTLENBQUUsZUFBZSxFQUFFLE9BQU8sQ0FBRSxDQUFDO0lBRXBFLG9CQUFvQjtJQUNwQixPQUFPLHFCQUFxQixDQUFDLElBQUksRUFBRSxDQUFDO0FBQ3JDLENBQUM7QUFSRCxzQ0FRQztBQUVEOzs7Ozs7Ozs7Ozs7R0FZRztBQUNILFNBQWdCLGlCQUFpQixDQUNoQyxlQUF1QixFQUN2QixVQUFrQyxFQUFFO0lBRXBDLE1BQU0scUJBQXFCLEdBQUcsU0FBUyxDQUFFLGVBQWUsRUFBRSxPQUFPLENBQUUsQ0FBQztJQUVwRSxvQkFBb0I7SUFDcEIscUJBQXFCLENBQUMsUUFBUSxFQUFFLENBQUM7QUFDbEMsQ0FBQztBQVJELDhDQVFDO0FBR0Q7Ozs7Ozs7Ozs7OztHQVlHO0FBQ0gsU0FBUyxTQUFTLENBQ2pCLGVBQXVCLEVBQ3ZCLFVBQWtDLEVBQUU7SUFFcEMsZ0JBQU0sQ0FBQyxXQUFXLENBQUUsT0FBTyxDQUFDLFFBQVEsSUFBSSxTQUFTLENBQUUsQ0FBQztJQUVwRCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFFLGVBQWUsQ0FBRSxDQUFDO0lBRXJELE1BQU0sWUFBWSxHQUFHLDhDQUFvQixDQUFFLFlBQVksRUFBRSxPQUFPLENBQUUsQ0FBQztJQUNuRSxPQUFPLGlCQUFPLENBQUUsWUFBWSxDQUFFLENBQUM7QUFDaEMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBjcmVhdGVUc01vcnBoUHJvamVjdCB9IGZyb20gXCIuL2NyZWF0ZS10cy1tb3JwaC1wcm9qZWN0XCI7XG5pbXBvcnQgeyBjb252ZXJ0IH0gZnJvbSBcIi4vY29udmVydGVyL2NvbnZlcnRcIjtcbmltcG9ydCB7IFByb2plY3QsIEluZGVudGF0aW9uVGV4dCB9IGZyb20gXCJ0cy1tb3JwaFwiO1xuaW1wb3J0IHsgTG9nTGV2ZWwgfSBmcm9tIFwiLi9sb2dnZXJcIjtcbmltcG9ydCBsb2dnZXIgZnJvbSBcIi4vbG9nZ2VyL2xvZ2dlclwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIEpzVG9Uc0NvbnZlcnRlck9wdGlvbnMge1xuXHRpbmRlbnRhdGlvblRleHQ/OiBJbmRlbnRhdGlvblRleHQsXG5cdGxvZ0xldmVsPzogTG9nTGV2ZWwsXG5cdGluY2x1ZGVQYXR0ZXJucz86IHN0cmluZ1tdLFxuXHRleGNsdWRlUGF0dGVybnM/OiBzdHJpbmdbXVxufVxuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IGNvbnZlcnRzIHRoZSBKYXZhU2NyaXB0IGZpbGVzIHVuZGVyIHRoZSBnaXZlbiBgc291cmNlRmlsZXNQYXRoYFxuICogdG8gVHlwZVNjcmlwdCBmaWxlcy5cbiAqXG4gKiBAcGFyYW0gc291cmNlRmlsZXNQYXRoIFRoZSBwYXRoIHRvIHRoZSBzb3VyY2UgZmlsZXMgdG8gY29udmVydFxuICogQHBhcmFtIFtvcHRpb25zXVxuICogQHBhcmFtIFtvcHRpb25zLmluZGVudGF0aW9uVGV4dF0gVGhlIHRleHQgdXNlZCB0byBpbmRlbnQgbmV3IGNsYXNzIHByb3BlcnR5XG4gKiAgIGRlY2xhcmF0aW9ucy5cbiAqIEBwYXJhbSBbb3B0aW9ucy5sb2dMZXZlbF0gVGhlIGxldmVsIG9mIGxvZ2dpbmcgdG8gc2hvdyBvbiB0aGUgY29uc29sZS5cbiAqICAgT25lIG9mOiAnZGVidWcnLCAndmVyYm9zZScsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InXG4gKiBAcGFyYW0gW29wdGlvbnMuaW5jbHVkZVBhdHRlcm5zXSBHbG9iIHBhdHRlcm5zIHRvIGluY2x1ZGUgZmlsZXMuXG4gKiBAcGFyYW0gW29wdGlvbnMuZXhjbHVkZVBhdHRlcm5zXSBHbG9iIHBhdHRlcm5zIHRvIGV4Y2x1ZGUgZmlsZXMuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb252ZXJ0SnNUb1RzKFxuXHRzb3VyY2VGaWxlc1BhdGg6IHN0cmluZyxcblx0b3B0aW9uczogSnNUb1RzQ29udmVydGVyT3B0aW9ucyA9IHt9XG4pOiBQcm9taXNlPHZvaWQ+IHtcblx0Y29uc3QgY29udmVydGVkVHNBc3RQcm9qZWN0ID0gZG9Db252ZXJ0KCBzb3VyY2VGaWxlc1BhdGgsIG9wdGlvbnMgKTtcblxuXHQvLyBTYXZlIG91dHB1dCBmaWxlc1xuXHRyZXR1cm4gY29udmVydGVkVHNBc3RQcm9qZWN0LnNhdmUoKTtcbn1cblxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IGNvbnZlcnRzIHRoZSBKYXZhU2NyaXB0IGZpbGVzIHVuZGVyIHRoZSBnaXZlbiBgc291cmNlRmlsZXNQYXRoYFxuICogdG8gVHlwZVNjcmlwdCBmaWxlcy5cbiAqXG4gKiBAcGFyYW0gc291cmNlRmlsZXNQYXRoIFRoZSBwYXRoIHRvIHRoZSBzb3VyY2UgZmlsZXMgdG8gY29udmVydFxuICogQHBhcmFtIFtvcHRpb25zXVxuICogQHBhcmFtIFtvcHRpb25zLmluZGVudGF0aW9uVGV4dF0gVGhlIHRleHQgdXNlZCB0byBpbmRlbnQgbmV3IGNsYXNzIHByb3BlcnR5XG4gKiAgIGRlY2xhcmF0aW9ucy5cbiAqIEBwYXJhbSBbb3B0aW9ucy5sb2dMZXZlbF0gVGhlIGxldmVsIG9mIGxvZ2dpbmcgdG8gc2hvdyBvbiB0aGUgY29uc29sZS5cbiAqICAgT25lIG9mOiAnZGVidWcnLCAndmVyYm9zZScsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InXG4gKiBAcGFyYW0gW29wdGlvbnMuaW5jbHVkZVBhdHRlcm5zXSBHbG9iIHBhdHRlcm5zIHRvIGluY2x1ZGUgZmlsZXMuXG4gKiBAcGFyYW0gW29wdGlvbnMuZXhjbHVkZVBhdHRlcm5zXSBHbG9iIHBhdHRlcm5zIHRvIGV4Y2x1ZGUgZmlsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0SnNUb1RzU3luYyhcblx0c291cmNlRmlsZXNQYXRoOiBzdHJpbmcsXG5cdG9wdGlvbnM6IEpzVG9Uc0NvbnZlcnRlck9wdGlvbnMgPSB7fVxuKSB7XG5cdGNvbnN0IGNvbnZlcnRlZFRzQXN0UHJvamVjdCA9IGRvQ29udmVydCggc291cmNlRmlsZXNQYXRoLCBvcHRpb25zICk7XG5cblx0Ly8gU2F2ZSBvdXRwdXQgZmlsZXNcblx0Y29udmVydGVkVHNBc3RQcm9qZWN0LnNhdmVTeW5jKCk7XG59XG5cblxuLyoqXG4gKiBQZXJmb3JtcyB0aGUgYWN0dWFsIGNvbnZlcnNpb24gZ2l2ZW4gYSBgc291cmNlRmlsZXNQYXRoYCwgYW5kIHJldHVybmluZyBhXG4gKiBgdHMtbW9ycGhgIFByb2plY3Qgd2l0aCB0aGUgY29udmVydGVkIHNvdXJjZSBmaWxlcy5cbiAqXG4gKiBAcGFyYW0gc291cmNlRmlsZXNQYXRoIFRoZSBwYXRoIHRvIHRoZSBzb3VyY2UgZmlsZXMgdG8gY29udmVydFxuICogQHBhcmFtIFtvcHRpb25zXVxuICogQHBhcmFtIFtvcHRpb25zLmluZGVudGF0aW9uVGV4dF0gVGhlIHRleHQgdXNlZCB0byBpbmRlbnQgbmV3IGNsYXNzIHByb3BlcnR5XG4gKiAgIGRlY2xhcmF0aW9ucy5cbiAqIEBwYXJhbSBbb3B0aW9ucy5sb2dMZXZlbF0gVGhlIGxldmVsIG9mIGxvZ2dpbmcgdG8gc2hvdyBvbiB0aGUgY29uc29sZS5cbiAqICAgT25lIG9mOiAnZGVidWcnLCAndmVyYm9zZScsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InXG4gKiBAcGFyYW0gW29wdGlvbnMuaW5jbHVkZVBhdHRlcm5zXSBHbG9iIHBhdHRlcm5zIHRvIGluY2x1ZGUgZmlsZXMuXG4gKiBAcGFyYW0gW29wdGlvbnMuZXhjbHVkZVBhdHRlcm5zXSBHbG9iIHBhdHRlcm5zIHRvIGV4Y2x1ZGUgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIGRvQ29udmVydChcblx0c291cmNlRmlsZXNQYXRoOiBzdHJpbmcsXG5cdG9wdGlvbnM6IEpzVG9Uc0NvbnZlcnRlck9wdGlvbnMgPSB7fVxuKTogUHJvamVjdCB7XG5cdGxvZ2dlci5zZXRMb2dMZXZlbCggb3B0aW9ucy5sb2dMZXZlbCB8fCAndmVyYm9zZScgKTtcblxuXHRjb25zdCBhYnNvbHV0ZVBhdGggPSBwYXRoLnJlc29sdmUoIHNvdXJjZUZpbGVzUGF0aCApO1xuXG5cdGNvbnN0IHRzQXN0UHJvamVjdCA9IGNyZWF0ZVRzTW9ycGhQcm9qZWN0KCBhYnNvbHV0ZVBhdGgsIG9wdGlvbnMgKTtcblx0cmV0dXJuIGNvbnZlcnQoIHRzQXN0UHJvamVjdCApO1xufSJdfQ==