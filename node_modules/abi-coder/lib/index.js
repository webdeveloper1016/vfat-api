"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
var abi_1 = require("@ethersproject/abi");
var keccak256_1 = require("@ethersproject/keccak256");
var strings_1 = require("@ethersproject/strings");
var Coder = /** @class */ (function () {
    function Coder(abi) {
        this.abi = abi;
    }
    Coder.prototype.getFunctionSelector = function (name) {
        var func = this.getFunctionByName(name);
        var jsonInputs = func === null || func === void 0 ? void 0 : func.inputs;
        if (!jsonInputs) {
            throw Error;
        }
        var inputs = jsonInputs.map(function (input) { return abi_1.ParamType.fromObject(input); });
        var signature = Coder.getSignature(name, inputs);
        var hash = sha3(signature);
        return hash.substring(0, 10);
    };
    Coder.prototype.getEventTopic = function (name) {
        var event = this.getEventByName(name);
        var jsonInputs = event === null || event === void 0 ? void 0 : event.inputs;
        if (!jsonInputs) {
            throw Error;
        }
        var inputs = jsonInputs.map(function (input) { return abi_1.ParamType.fromObject(input); });
        var signature = Coder.getSignature(name, inputs);
        return sha3(signature);
    };
    Coder.prototype.decodeConstructor = function (data) {
        var constructor = this.getConstructor();
        var jsonInputs = constructor === null || constructor === void 0 ? void 0 : constructor.inputs;
        if (!jsonInputs) {
            throw Error;
        }
        var inputs = jsonInputs.map(function (input) { return abi_1.ParamType.fromObject(input); });
        var result = abi_1.defaultAbiCoder.decode(inputs, data);
        return {
            inputs: inputs,
            values: result,
        };
    };
    Coder.prototype.decodeEvent = function (topics, data) {
        var event = this.getEventByTopic(topics[0]);
        var dataTopics = topics.slice(1);
        var jsonInputs = event === null || event === void 0 ? void 0 : event.inputs;
        if (!jsonInputs) {
            throw Error;
        }
        var inputs = jsonInputs.map(function (input) { return abi_1.ParamType.fromObject(input); });
        // Decode topics
        var topicInputs = inputs.filter(function (input) { return input.indexed; });
        var topicResult = topicInputs.map(function (input, index) {
            var topic = dataTopics[index];
            var params = abi_1.defaultAbiCoder.decode([input], topic);
            var param = params[0];
            return param;
        });
        // Decode data
        var dataInputs = inputs.filter(function (input) { return !input.indexed; });
        var dataResult = abi_1.defaultAbiCoder.decode(dataInputs, data);
        // Concat
        if (!event.name) {
            throw Error;
        }
        var topicIndex = 0;
        var dataIndex = 0;
        var result = [];
        for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {
            var input = inputs_1[_i];
            if (input.indexed) {
                result.push(topicResult[topicIndex]);
                topicIndex++;
            }
            else {
                result.push(dataResult[dataIndex]);
                dataIndex++;
            }
        }
        return {
            name: event.name,
            inputs: inputs,
            values: result,
        };
    };
    Coder.prototype.decodeFunction = function (data) {
        var selector = data.substring(0, 10);
        var func = this.getFunctionBySelector(selector);
        // Decode calldata using function inputs
        var jsonInputs = func === null || func === void 0 ? void 0 : func.inputs;
        if (!jsonInputs) {
            throw Error;
        }
        var inputs = jsonInputs.map(function (input) { return abi_1.ParamType.fromObject(input); });
        var calldata = "0x".concat(data.substring(10));
        var result = abi_1.defaultAbiCoder.decode(inputs, calldata);
        if (!func.name) {
            throw Error;
        }
        return {
            name: func.name,
            inputs: inputs,
            values: result,
        };
    };
    Coder.prototype.decodeFunctionOutput = function (name, data) {
        var func = this.getFunctionByName(name);
        var jsonOutputs = func === null || func === void 0 ? void 0 : func.outputs;
        if (!jsonOutputs) {
            throw Error;
        }
        var outputs = jsonOutputs.map(function (output) { return abi_1.ParamType.fromObject(output); });
        var result = abi_1.defaultAbiCoder.decode(outputs, data);
        return {
            name: name,
            outputs: outputs,
            values: result,
        };
    };
    Coder.prototype.encodeConstructor = function (values) {
        var constructor = this.getConstructor();
        var jsonInputs = constructor === null || constructor === void 0 ? void 0 : constructor.inputs;
        if (!jsonInputs) {
            throw Error;
        }
        var inputs = jsonInputs.map(function (input) { return abi_1.ParamType.fromObject(input); });
        return abi_1.defaultAbiCoder.encode(inputs, values);
    };
    Coder.prototype.encodeEvent = function (name, values) {
        var event = this.getEventByName(name);
        var jsonInputs = event === null || event === void 0 ? void 0 : event.inputs;
        if (!jsonInputs) {
            throw Error;
        }
        var inputs = jsonInputs.map(function (input) { return abi_1.ParamType.fromObject(input); });
        var eventSignature = Coder.getSignature(name, inputs);
        var eventTopic = sha3(eventSignature);
        // Group params by type
        var topicResult = [];
        var dataResult = [];
        for (var i = 0; i < inputs.length; i++) {
            var input = inputs[i];
            var value = values[i];
            if (input.indexed) {
                topicResult.push(value);
            }
            else {
                dataResult.push(value);
            }
        }
        // Encode topic params
        var topicInputs = inputs.filter(function (input) { return input.indexed; });
        var dataTopics = topicInputs.map(function (input, index) {
            return abi_1.defaultAbiCoder.encode([input], [topicResult[index]]);
        });
        var topics = __spreadArray([eventTopic], dataTopics, true);
        // Encode data params
        var dataInputs = inputs.filter(function (input) { return !input.indexed; });
        var data = abi_1.defaultAbiCoder.encode(dataInputs, dataResult);
        return {
            topics: topics,
            data: data,
        };
    };
    Coder.prototype.encodeFunction = function (name, values) {
        var func = this.getFunctionByName(name);
        var jsonInputs = func === null || func === void 0 ? void 0 : func.inputs;
        if (!jsonInputs) {
            throw Error;
        }
        var inputs = jsonInputs.map(function (input) { return abi_1.ParamType.fromObject(input); });
        var signature = Coder.getSignature(name, inputs);
        var selector = sha3(signature).substring(2, 10);
        var argumentString = abi_1.defaultAbiCoder.encode(inputs, values);
        var argumentData = argumentString.substring(2);
        var inputData = "0x".concat(selector).concat(argumentData);
        return inputData;
    };
    Coder.prototype.encodeFunctionOutput = function (name, values) {
        var func = this.getFunctionByName(name);
        var jsonOutputs = func.outputs;
        if (!jsonOutputs) {
            throw Error;
        }
        var outputs = jsonOutputs.map(function (output) { return abi_1.ParamType.fromObject(output); });
        return abi_1.defaultAbiCoder.encode(outputs, values);
    };
    Coder.prototype.getConstructor = function () {
        var constructor = this.abi.find(function (item) { return item.type === 'constructor'; });
        if (!constructor) {
            throw Error;
        }
        return constructor;
    };
    Coder.prototype.getFunctionByName = function (name) {
        var func = this.abi.find(function (item) { return item.type === 'function' && item.name === name; });
        if (!func) {
            throw Error;
        }
        return func;
    };
    Coder.prototype.getFunctionBySelector = function (selector) {
        var functions = this.abi.filter(function (item) { return item.type === 'function'; });
        var func = functions.find(function (func) {
            var name = func.name;
            var jsonInputs = func.inputs;
            if (!name || !jsonInputs) {
                return false;
            }
            var inputs = jsonInputs.map(function (input) { return abi_1.ParamType.fromObject(input); });
            var signature = Coder.getSignature(name, inputs);
            var hash = sha3(signature);
            var funcSelector = hash.substring(0, 10);
            return funcSelector === selector;
        });
        if (!func) {
            throw Error;
        }
        return func;
    };
    Coder.prototype.getEventByName = function (name) {
        var event = this.abi.find(function (item) { return item.type === 'event' && item.name === name; });
        if (!event) {
            throw Error;
        }
        return event;
    };
    Coder.prototype.getEventByTopic = function (topic) {
        var events = this.abi.filter(function (item) { return item.type === 'event'; });
        var event = events.find(function (event) {
            var name = event.name;
            var jsonInputs = event.inputs;
            if (!name || !jsonInputs) {
                return false;
            }
            var inputs = jsonInputs.map(function (input) { return abi_1.ParamType.fromObject(input); });
            var signature = Coder.getSignature(name, inputs);
            var eventTopic = sha3(signature);
            return eventTopic === topic;
        });
        if (!event) {
            throw Error;
        }
        return event;
    };
    Coder.getSignature = function (name, inputs) {
        var types = [];
        for (var _i = 0, inputs_2 = inputs; _i < inputs_2.length; _i++) {
            var input = inputs_2[_i];
            if (input.type.startsWith('tuple')) {
                var tupleString = Coder.getSignature('', input.components);
                var arrayArityString = input.type.substring('tuple'.length);
                var type = "".concat(tupleString).concat(arrayArityString);
                types.push(type);
            }
            else {
                types.push(input.type);
            }
        }
        var typeString = types.join(',');
        var functionSignature = "".concat(name, "(").concat(typeString, ")");
        return functionSignature;
    };
    return Coder;
}());
function sha3(input) {
    return (0, keccak256_1.keccak256)((0, strings_1.toUtf8Bytes)(input));
}
exports.default = Coder;
